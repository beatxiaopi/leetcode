//Binary search + BFS
class Solution {
public:
    int minimumEffortPath(vector<vector<int>>& heights) {
        int left = 0, right = 1e6;
        while (left < right) {
            int mid = left + (right - left)/2;
            // int mid = right - (right - left)/2;
            if (check(heights, mid)) right = mid;
            else left = mid + 1;
        }
        return left;
    }
    
    bool check(vector<vector<int>>& heights, int h) {
        int m = heights.size(), n = heights[0].size();
        vector<vector<int>>visited(m, vector<int>(n, 0));
        visited[0][0] = 1;
        vector<pair<int,int>> dir = {{1,0}, {-1,0}, {0,1}, {0,-1}};
        queue<pair<int,int>>q;
        q.push({0,0});
        while (!q.empty()) {
            int a = q.front().first;
            int b = q.front().second;
            q.pop();
            for (int k = 0; k < 4; k++) {
                int x = a + dir[k].first;
                int y = b + dir[k].second;
                if (x < 0 || x >= m || y < 0 || y >= n) continue;
                if (abs(heights[a][b] - heights[x][y]) > h) continue;
                if (visited[x][y]) continue;
                q.push({x,y});
                visited[x][y] = 1;
            }
        }
        return visited[m - 1][n - 1] == 1;
    }
};

