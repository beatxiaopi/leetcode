class Solution {
    int [] root;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        Arrays.sort(initial);
        root = new int[n];
        for (int i = 0; i < n; i++) {
            root[i] = i;
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i != j && graph[i][j] == 1 && findRoot(i) != findRoot(j)) {
                    union(i, j);
                }
            }
        }
        Map<Integer, Integer> childNum = new HashMap<>();

        for (int i=0; i < n; i++) {
            childNum.put(root[i], childNum.getOrDefault(root[i], 0)+1);
        }
        int infect = 0;
        int res = -1;
        Map<Integer, List<Integer>> countInitial = new HashMap<>();
        for (int j : initial) {
            List<Integer> temp = countInitial.getOrDefault(root[j], new ArrayList<>());
            temp.add(j);
            countInitial.put(root[j], temp);
        }
        for (int root : countInitial.keySet()) {
            if (countInitial.get(root).size() ==1) {
                if (infect < childNum.get(root)) {
                    infect = childNum.get(root);
                    res = countInitial.get(root).get(0);
                }
                else if (infect == childNum.get(root)) {
                    res = Math.min(res, countInitial.get(root).get(0));
                }
            }
        }
        return res == -1 ? initial[0]:res;
    }
    private int findRoot(int x) {
        if (root[x]!=x) {
            root[x] = findRoot(root[x]);
        }
        return root[x];
    }
    
    private void union(int x, int y) {
        x = root[x];
        y = root[y];
        if (x < y) {
            root[y] = x;
        }
        else root[x] = y;
    }
}
